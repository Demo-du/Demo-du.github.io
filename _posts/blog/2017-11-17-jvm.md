---
layout: post
title:  GC相关知识（一）
categories: jvm
description: 
keywords: 
---


## 1、回收算法

早期，很多公司都采用引用计数法。但该算法无法解决对象之间相互引用的问题。

因此，现在大多采用的是可达性分析法，通过一系列称为“GC Roots”的对象作为起始点，从这些点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

其中，以下几种可作为GC Roots的对象：

·虚拟机栈（栈帧中的本地变量表）中引用的对象。

·方法区中类静态引用的对象。

·方法区中常量引用的对象。

·本地方法栈中JNI（即一般说的Native方法）引用的对象。

## 2、在谈引用

引用分为四种：强引用，软引用，弱引用，虚引用。

·强引用：类似Object a=new Object();，只要强引用还在，就不会回收被引用对象。

·软引用：描述一些还有用但非必须的对象。在系统发生内存溢出异常之前进行回收，如果此次回收还没有获得足够内存，再抛出内存溢出异常。JDK1.2后，SoftReference实现软引用。

·弱引用：也是用来描述非必须对象，比软引用还弱，只能生存到下一次GC之前。JDK1.2后，WeakReference实现软引用。

·虚引用：最弱。为一个对象设置虚引用关联的唯一目的就是能在这个对象GC时收到一个系统通知。JDK1.2后，PhantomReference实现软引用。

## 3、判断对象是否“死亡”

在可达性分析算法中，即使是不可达的对象，也并非“非死不可”。宣告“死亡”，要经历两次标记：

·如果对象在可达性分析中没有雨GC Roots相连的引用链，会被第一次标记。

·被第一次标记后，进行筛选，条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或finalize()方法已经被虚拟机调用，则没有必要执行。如果对象在finalize()方法中解救自己（只要重新与引用链上任何一个对象建立关联），就不会被回收；否则，发生回收。

## 4、回收方法区

在堆中，永久代的垃圾回收效率远低于新生代。

永久代GC主要回收两部分内容：废弃常量和无用的类。

·废弃常量：例如，常量池有“abc”，当前系统没有任何String对象引用“abc”。

·无用的类：需要满足以下三点

（1）该类所有实例都已经被回收，也就是java堆中不存在该类的任何实例。

（2）加载该类的ClassLoader已经被回收

（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。

## 5、垃圾回收算法

### 标记-清除算法

先标记，任何回收被标记的对象。

不足：一是效率不高，另一个是空间问题--会产生大量不连续碎片，后续需要分配较大对象时，不得不提前触发另一次GC。

### 复制算法

内存分为两块，一块用完后，将存活的对象复制到另一块，然后把已经使用过的内存空间一次清理掉。

不足：内存缩小为原来的一半，代价太大。

### 标记-整理算法

过程与标记清除算法相似，后续不是直接对可回收对象清理，耳熟让存活对象向一端移动，清理掉端边界以外的内存。

### 分代收集算法

将堆分为老年代和新生代。在新生代，每次GC都有大批对象死去，只有少数存活，采用复制算法。老年代存活率高，没有额外空间对他进行分配担保，采用标记-清除算法或者标记-整理算法。
