---
layout: post
title:  虚拟机类加载机制（二）
categories: jvm
description: 
keywords: 
---


## 类加载器

通过一个类的全限定名来获取描述此类的二进制字节流，完成这个动作的代码模块称为“类加载器”。

### 类与类加载器

对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都有一个独立的类名空间。通俗讲：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。

### 双亲委派模型

类加载器分为两种：一种是启动类加载器，是虚拟机自身的一部分；一直就是其他的类加载器，这些类加载器由Java语言实现，独立于虚拟机外面，并且全部继承自java.lang.ClassLoader。

再细分，可分为3种：

··启动类加载器：前面提到了。

··扩展类加载器：负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径的所有类库，开发者可以直接使用扩展类加载器。

··应用程序类加载器：负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。如果程序中没有自定义过自己的类加载器，一般这个就是程序中默认的类加载器。

                                     启动类加载器

                                         /\

                                         ||

                                     扩展类加载器

                                         /\

                                         ||

                                    应用程序类加载器

                                      /\          /\

                                      ||          ||

                              自定义类加载器     自定义类加载器

上图所展示的层次关系，称为类加载的双亲委托模型。双亲委托模型除了顶层的启动类加载器外，其余的类加载器都有自己的父类加载器。父子关系一般不是以继承的关系来实现，而是以组合的关系来实现。

工作过程：如果一个类加载器都到了类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，因此所有的加载请求最终都应该传送到顶层的启动类加载器，只有当父加载器反馈自己无法完成加载请求，子类才会尝试自己去加载。

好处：Java类随着他的类加载器一起具备了一种带有优先级的层次关系，保证程序的稳定运行。

例如：java.lang.Object，它存放在r.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。



                          
