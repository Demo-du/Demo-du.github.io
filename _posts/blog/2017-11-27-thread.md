---
layout: post
title:  Java中的线程池
categories: Java并发
description: 
keywords: 
---

JAVA中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行的任务的程序都可以使用线程池。

## 线程池好处：

- 降低线程创建和销毁造成的资源损耗。
- 提高响应速度：任务到达时，可以装载到线程中执行，而不必等到线程创建完毕。
- 提高线程的可管理性：使用线程池可以进行统一分配、调优和监控。
- 控制最大并发数，避免阻塞。

## **线程池的实现原理**

**当使用者向线程池提交一个任务之后，线程池的处理流程如下：**

1. 首先线程池判断**基本线程池**是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。
2. 其次线程池判断**工作队列**是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。
3. 最后线程池判断**整个线程池**是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。

![这里写图片描述](http://img.blog.csdn.net/20160808030606565)

**ThreadPoolExecutor执行execute方法分下面4种情况。** 

1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤 
需要获取全局锁）。 
2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。 
3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执 
行这一步骤需要获取全局锁）。 
4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用 
RejectedExecutionHandler.rejectedExecution()方法。 
ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能 
地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后 
（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而 
步骤2不需要获取全局锁。

**工作线程：**线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务 
后，还会循环获取工作队列里的任务来执行。我们可以从Worker类的run()方法里看到这点。

## **线程池的使用**

#### **线程池的创建**

我们可以通过ThreadPoolExecutor来创建一个线程池。

```
new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,
milliseconds,runnableTaskQueue, handler);
```

创建一个线程池时需要输入几个参数，如下。 

**①corePoolSize**:线程池的基本大小，即核心干将的数量上限。当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建该类线程，等到执行的任务书大于线程池基本大小时就不在创建。

**②runnableTaskQueue**:任务队列，用于保存等待执行的任务的阻塞队列，又分为基于链表结构的队列，基于数组结构的队列，具有优先级的无限阻塞队列等。

**③maxinumPoolSize**：线程池的最大数量，也就是线程池可以创建的线程的最大数，如果使用了无界的任务队列这个参数就没有什么效果。

**④ThreadFactory**：用于设置创建线程的工厂。

**⑤RejectedExecutionHandler**：饱和策略，线程池不能承载任务时采用的处理多余任务的方式，有抛出异常、丢弃队列里最近的一个任务并执行当前任务、不处理并且丢弃任务等策略。

****向线程池提交任务****

可以使用2个方法，execute（）和submit（）。

execute（）用于提交无返回值的任务，submit（）用于提交有返回值的任务。

#### **关闭线程池**

2个方法，shutdown（）和shutdownNown（）。它们的普遍原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程。

shutdown（）会中断所有没有正在执行任务的线程，shutdownNown（）会关闭所有线程，而不会管任务是否执行完毕。

## **线程池的监控**

监控线程池的时候可以使用下面几个属性：

**1.taskCount**:线程需要执行的任务数目。

**2.completedTasdCount:**线程池在运行过程中已完成的任务数量，小于或者等于taskCount。

**3.targestPoolSize**:线程池中曾经存在的线程的最大数量。通过该属性可以知道线程池是否满过。

**4.getPoolSize:**线程池内的线程数量。如果线程池不销毁，线程池里的线程不会自动销毁，所以该属性只增不减

**5.getActiveCount:**获取活动的线程数。

**阻塞队列的作用：**

线程池创建线程需要获取mainlock这个全局锁，影响并发效率，阻塞队列可以很好的缓冲。