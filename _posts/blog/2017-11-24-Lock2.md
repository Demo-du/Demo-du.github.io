---
layout: post
title:  Java中的锁（二）
categories: Java并发
description: 
keywords: 
---


## 读写锁

之前提到的锁如Mutex和ReentrantLock都是排它锁，这些锁同一时刻都只允许一个线程进行访问。而读写锁在同一时刻可以允许多个读线程进行访问，但在写线程访问时，所有的其他读线程和写线程均被阻塞。

读写锁维护了一个同步器，一个读锁和一个写锁。读锁lock（）时调用同步器的tryAcquireShared方法，写锁lock（）时调用同步器tryAcquire方法。

实际操作过程，只需要在读操作的时候获取读锁，写操作的时候获取写锁即可。一般情况下，读写锁的性能比排它锁好，因为大多数场景都是读多于写的。Java并发包提供读写锁的实现是ReetrantReadWriteLock，特性如下：

1、公平性选择：支持非公平（默认）和公平的获取锁方式，吞吐量还是非公平优于公平

2、重进入：该锁支持重进入，以读锁为例，读线程在获取了读锁之后，能够再次获取读锁，而写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁。

3、锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁

### 读写锁的实现分析

1、对写状态的设计

读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。回想ReentrantLock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。

当前同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。读写锁是如何迅速的确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态值为S，写状态等于 S & 0x0000FFFF（将高16位全部抹去），读状态等于 S >>> 16（无符号补0右移16位）。当写状态增加1时，等于S + 1，当读状态增加1时，等于S + (1 << 16)，也就是S + 0x00010000。

根据状态的划分能得出一个推论：S不等于0时，当写状态(S & 0x0000FFFF)等于0时，则读状态(S >>> 16)大于0，即读锁已被获取。

2、写锁的获取与释放

写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。

 该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。

如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。

 因此只有等待其他读线程都释放了读锁，写锁才能被当前线程所获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。

写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对后续读写线程可见。

3、读锁的获取与释放

 读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会成功的被获取，而所做的也只是（线程安全的）增加读状态。

如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。

 在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程(线程安全，依靠CAS保证)增加读状态，成功获取读锁。

读锁的每次释放均（线程安全的，可能有多个读线程同时释放读锁）减少读状态，减少的值是(1 << 16)。

4、锁降级

锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。

## Condition接口

任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait（），wait（long timeout），notify（）以及notifyAll（）方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。

Condition接口定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象（调用Lock对象的newCondition（）方法）创建出来的，换句话来说，Condition是依赖Lock对象的。

Object的监视器方法与Condition接口的对比：

（1）Condition支持在等待状态中不响应中断（void awaitUninterruptibly）。

（2）Condition支持当前线程释放锁并进入等待状态直至将来某个时间（boolean awaitUntil（Date deadline） throws InterruptedException）。

Condition的部分方法以及描述：

（1）void await（） throws InterruptedException：当前线程进入等待状态直至被通知（signal）或被中断。如果当前线程从await（）方法中返回，那么表明该线程已经或得了Condition对象所对应的锁。

（2）void awaitUninterruptibly（）：当前线程进入等待状态，不响应中断。

（3）long awaitNanos（long nanosTimeout）throws InterruptedException：当前线程进入等待状态直到被通知，中断或者超时。返回值表示剩余时间（nanosTimeout-实际耗时），如果返回值是0或者负数，那么可以认定超时了。

（4）boolean awaitUntil（Date deadline） throws InterruptedException：当前线程进入等待状态直到被通知，中断或者到达某个时间点。如果没有到达某个时间点就被通知，方法返回true，否则表示到达了指定时间，方法返回false。

（5）void signal（）：唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition相关联的锁。

（6）void signalAll（）：唤醒所有等待在Condition上的线程，能够从等待方法返回的线程必须获得与Condition相关联的锁。

